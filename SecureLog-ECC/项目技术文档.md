# SecureLog ECC 项目技术文档

## 项目概述

SecureLog ECC 是一个基于国密算法的日志加密组件，为业务系统提供敏感数据加密保护。该组件采用双轨密钥管理系统，支持基于trace_id的会话密钥和系统级密钥两种加密策略。

## 核心技术特性

### 1. 双轨密钥管理系统

- **会话密钥**：基于trace_id的密钥管理，每个trace_id对应独立的密钥
- **系统级密钥**：按时间间隔变化的密钥管理，用于没有trace_id的系统日志

### 2. 国密算法支持

- **SM2**：非对称加密算法，用于加密对称密钥
- **SM4**：对称加密算法，用于加密敏感数据
- **Bouncy Castle**：密码学提供者，支持国密算法

### 3. 高性能缓存管理

- **ConcurrentHashMap**：线程安全的主缓存结构
- **ConcurrentLinkedQueue**：时间戳队列，按创建时间顺序清理
- **无过期时间**：缓存占满后按创建时间清理最旧的密钥

## 系统架构

### 核心组件

#### 1. SecureDataBuilder

- **功能**：构建SECURE_DATA加密字段
- **输入**：敏感数据、trace_id（可选）
- **输出**：Base64编码的SECURE_DATA字符串
- **说明**：不直接依赖日志框架上下文；trace_id 的获取由调用方（如 LogMaskingProcessor）负责

#### 2. KeyManager

- **功能**：密钥管理核心组件
- **缓存策略**：
    - 会话密钥缓存：默认30,000条（可配置：`ecc.session.key.cache.size`）
    - 系统密钥缓存：默认1,000条（可配置：`ecc.system.key.cache.size`）
    - 清理缓冲百分比：可配置（`ecc.session.key.cache.buffer.percentage`、`ecc.system.key.cache.buffer.percentage`）
- **线程安全**：使用ConcurrentHashMap和ConcurrentLinkedQueue
- **淘汰策略**：按创建顺序FIFO淘汰（队列仅记录创建顺序，不基于访问刷新）

#### 3. ConfigManager

- **功能**：统一配置管理
- **配置源**：配置文件 + 默认值
- **线程安全**：单例模式，支持并发访问

#### 4. LogMaskingProcessor

- **功能**：日志脱敏与SECURE_DATA生成工具类
- **作用**：提供敏感数据检测和加密功能
- **自动检测**：基于正则表达式自动识别敏感数据和trace_id
- **独立组件**：不依赖特定日志框架，可灵活集成

#### 5. SecureDataDecrypter

- **功能**：解密SECURE_DATA（Base64）并还原敏感数据JSON
- **输入**：SECURE_DATA（Base64）、ECC私钥（PKCS8 Base64 或 PrivateKey）
- **输出**：明文敏感数据（UTF-8字符串，通常为JSON）

#### 6. 日志框架适配层

- **logback.SecureMaskingAppender**：Logback Appender 包装器，在转发前脱敏
- **log4j2.SecureMaskingPolicy**：Log4j2 RewritePolicy，在转发前脱敏
- **统一模式**：适配层统一基于 LogMaskingProcessor 进行敏感数据提取、加密与脱敏
- **集成方式**：通过日志框架配置引用，将脱敏下沉到输出链路

### 3. 日志框架集成

#### 支持的日志框架

- **Logback**：通过 Appender 转发脱敏集成
- **Log4j2**：通过 RewritePolicy 转发脱敏集成

#### 集成模式

所有适配实现遵循相同的处理模式：

1. **格式化**：先按用户 pattern 输出文本
2. **敏感数据处理**：从文本提取敏感键值对→拼装JSON→生成SECURE_DATA
3. **写入 MDC**：将 SECURE_DATA 写入 `org.slf4j.MDC`（Key 由 `mdc.secure.data.key` 配置）
4. **返回脱敏结果**：返回脱敏后的日志文本（敏感值替换为***）

#### 配置示例

```xml
<!-- Logback 配置示例：SecureMaskingAppender 包装下游 appender -->
<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
        <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
</appender>

<appender name="SECURE_CONSOLE" class="team.frog.securelogecc.logback.SecureMaskingAppender">
<appender-ref ref="CONSOLE"/>
</appender>
```

### 4. 敏感数据处理流程

#### LogMaskingProcessor.processLog() 方法流程

1. **一次扫描完成两件事**：基于正则提取敏感字段键值对，并生成脱敏后的日志文本
2. **JSON转换**：将敏感键值对转换为JSON字符串
3. **trace_id识别**：优先从上下文获取，否则从原始日志文本提取
4. **加密处理**：trace_id 存在则生成“会话密钥”SECURE_DATA，否则生成“系统密钥”SECURE_DATA
5. **返回结果**：返回脱敏后的日志文本（将敏感值替换为***）

## 技术实现详解

### 1. 密钥管理机制

#### 缓存设计

- **数据结构**：ConcurrentHashMap + ConcurrentLinkedQueue
- **线程安全**：并发容器 + 乐观清理（高并发下允许一定不精确以换取性能）
- **淘汰策略**：FIFO（按创建顺序淘汰最旧密钥）
- **清理机制**：缓存达到上限后清理到目标大小（目标大小=cacheSize*(1-bufferPercentage)）

#### 配置参数

```properties
# 会话密钥缓存配置
ecc.session.key.cache.size=30000
ecc.session.key.cache.buffer.percentage=0.05

# 系统密钥缓存配置  
ecc.system.key.cache.size=1000
ecc.system.key.cache.buffer.percentage=0.1

# 系统标识符变化间隔（分钟）
ecc.system.id.change.interval.minutes=15
```

#### 缓存策略说明

- **会话密钥缓存**：用于存储用户会话相关的临时密钥，缓存较大（30,000条）
- **系统密钥缓存**：用于存储系统级别的长期密钥，缓存较小（1,000条）
- **清理缓冲百分比**：当缓存达到容量时，保留指定百分比的空间用于新密钥，避免频繁清理
    - 会话密钥：保留95%空间（清理5%）
    - 系统密钥：保留90%空间（清理10%）

### 2. 密钥生成流程

```java
// 生成SM4对称密钥
SecretKey sm4Key = generateSymmetricKey();

// 使用SM2加密SM4密钥
byte[] sm2EncryptedKey = EccCore.encrypt(sm4Key.getEncoded(), configuredPublicKey);

// 创建KeyInfo对象
KeyInfo keyInfo = new KeyInfo(sm4Key, sm2EncryptedKey, System.currentTimeMillis());
```

### 2. 缓存管理策略

#### 数据结构

```java
// 主缓存：ConcurrentHashMap
private final Map<String, KeyInfo> sessionKeyCache = new ConcurrentHashMap<>();
private final Map<String, KeyInfo> systemKeyCache = new ConcurrentHashMap<>();

// 时间戳队列：ConcurrentLinkedQueue
private final ConcurrentLinkedQueue<CacheEntry> sessionAccessQueue = new ConcurrentLinkedQueue<>();
private final ConcurrentLinkedQueue<CacheEntry> systemAccessQueue = new ConcurrentLinkedQueue<>();
```

#### 清理算法

```java
// 当缓存达到上限时，从队列头部移除最旧的密钥
while (cache.size() > targetSize && !accessQueue.isEmpty()) {
    CacheEntry oldest = accessQueue.poll();
    if (oldest != null && cache.containsKey(oldest.key)) {
        cache.remove(oldest.key);
    }
}
```

### 3. 简化高效的密钥获取

```java
public KeyInfo getOrCreateSessionKeyInfo(String traceId) throws Exception {
    // 能取到就返回
    KeyInfo keyInfo = sessionKeyCache.get(traceId);
    if (keyInfo != null) {
        return keyInfo;
    }
  
    // 没有取到就生成
    long currentTime = System.currentTimeMillis();
    SecretKey sm4Key = generateSymmetricKey();
    byte[] sm2EncryptedKey = EccCore.encrypt(sm4Key.getEncoded(), configuredPublicKey);
  
    keyInfo = new KeyInfo(sm4Key, sm2EncryptedKey, currentTime);
    sessionKeyCache.put(traceId, keyInfo);
    sessionAccessQueue.offer(new CacheEntry(traceId, currentTime));
  
    // 生成后数量超了就清理
    if (sessionKeyCache.size() >= sessionKeyCacheSize) {
        evictOldestSessionKeys();
    }
  
    return keyInfo;
}
```

**简化设计优势**：

- **极致性能**：99%情况下无锁直接返回
- **代码简洁**：逻辑清晰，易于维护
- **最终一致性**：即使多个线程创建相同密钥，最终结果一致
- **时间一致性**：使用统一时间戳，避免时间不一致问题

### 4. 系统标识符生成

```java
private String generateSystemTraceId() {
    long currentTime = System.currentTimeMillis();
    // 从配置读取系统标识符变化间隔（分钟）
    int systemIdChangeIntervalMinutes = ConfigManager.getInstance().getIntProperty(
        ConfigConstants.SYSTEM_ID_CHANGE_INTERVAL_MINUTES, 
        ConfigConstants.DEFAULT_SYSTEM_ID_CHANGE_INTERVAL_MINUTES
    );
    // 计算当前时间属于第几个时间间隔
    long intervalId = currentTime / (systemIdChangeIntervalMinutes * ConfigConstants.MILLIS_PER_MINUTE);
    return "system_" + intervalId;
}
```

**示例**：配置为15分钟

- 0-14分钟：`system_0`
- 15-29分钟：`system_1`
- 30-44分钟：`system_2`

## 配置管理

### 配置文件（securelog-ecc.properties）

```properties
# ECC公钥（Base64编码）
ecc.public.key=MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEZ+o3pJ44RBZsglVyMpf0VwBtmqWOjTo5vSAaJJsbZrPywgmIZ3wE9qQRKRcO5kUq0A1yRkjNUM33BiKINItCFg==

# 密码学提供者与算法参数
# ecc.crypto.provider 必须填写Provider类名全路径（如org.bouncycastle.jce.provider.BouncyCastleProvider）
ecc.crypto.provider=org.bouncycastle.jce.provider.BouncyCastleProvider
ecc.sm2.curve.name=sm2p256v1
ecc.sm2.cipher.transformation=SM2
ecc.sm4.cipher.transformation=SM4/GCM/NoPadding

# 脱敏配置（强敏感）
ecc.masking.sensitive.keys=password,pwd,pass,token,access_token,clientSecret,secret,apiKey,idcard,cardNumber,jbrCardNumber,mobile,phone,email,address
ecc.masking.token.keep.prefix=4
ecc.masking.token.keep.suffix=4
ecc.masking.max.value.length=50
ecc.masking.high.entropy.min.length=20
ecc.masking.high.entropy.threshold=3.5
ecc.masking.tokenlike.keys=token,access_token,clientSecret,secret,apiKey,key,auth,credential
ecc.masking.querystring.enabled=true
ecc.masking.fallback.enabled=true
ecc.masking.address.require.region=true
ecc.masking.address.require.detail=true
ecc.masking.address.region.keywords=省,市,区,县
ecc.masking.address.detail.keywords=街,路,道,巷,镇,乡,号,院,楼,室
ecc.masking.address.exclude.keywords=
ecc.masking.high.entropy.enabled=true
ecc.masking.high.entropy.require.upper.lower.digit=true

# MDC中存储SECURE_DATA的键名
mdc.secure.data.key=SECURE_DATA

# MDC中trace_id可能出现的Key（逗号分隔）
mdc.trace.id.keys=trace_id,traceId,requestId,correlationId,X-Trace-Code,X-Trace-Id

# 会话密钥缓存配置
ecc.session.key.cache.size=30000
ecc.session.key.cache.buffer.percentage=0.05

# 系统密钥缓存配置
ecc.system.key.cache.size=1000
ecc.system.key.cache.buffer.percentage=0.1

# 系统标识符变化间隔（分钟）
ecc.system.id.change.interval.minutes=15
```

### 脱敏行为说明

- 配置文件建议使用 UTF-8 编码保存（项目侧按 UTF-8 加载）。
- 结构化脱敏优先级：JSON → SQL Parameters → URL/querystring → key/value 对 → 纯文本兜底。
- SQL Parameters 日志（`==> Parameters: ...`）：对所有 `(String)` 参数一律脱敏；命中身份证/手机号/邮箱/严格地址时按对应规则格式化，否则替换为 `***`。
- URL 中的 query 参数（如 `...?token=...&password=...`）会被识别并逐项脱敏，不受前缀文本影响。

## SECURE_DATA 解密

### 输入与输出

- **输入**：
    - `secureData`：SECURE_DATA（Base64）
    - `privateKey`：ECC私钥（PKCS8 Base64字符串，或 `java.security.PrivateKey`）
- **输出**：解密后的敏感数据明文（UTF-8字符串，通常为JSON）

### 使用示例（ECC私钥为Base64）

```java
String plaintextJson = team.frog.securelogecc.SecureDataDecrypter.decryptSecureData(secureDataBase64, eccPrivateKeyBase64);
```

### 使用示例（先解析私钥）

```java
java.security.PrivateKey pk = team.frog.securelogecc.SecureDataDecrypter.decodePrivateKey(eccPrivateKeyBase64);
String plaintextJson = team.frog.securelogecc.SecureDataDecrypter.decryptSecureData(secureDataBase64, pk);
```

### 配置常量（ConfigConstants.java）

```java
// 时间单位常量
public static final long MILLIS_PER_SECOND = 1000L;
public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;
public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;
public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;

// 系统标识符变化间隔配置
public static final String SYSTEM_ID_CHANGE_INTERVAL_MINUTES = "ecc.system.id.change.interval.minutes";
public static final int DEFAULT_SYSTEM_ID_CHANGE_INTERVAL_MINUTES = 15;
```

## SECURE_DATA 数据结构详解

### SECURE_DATA 组成结构

`SECURE_DATA` 是一个 Base64 编码的字节数组，采用混合加密方案，包含三个部分：

```
[4字节长度信息] + [SM2加密的密钥] + [SM4加密的敏感数据]
```

#### 1. 长度信息（4字节）

- **作用**：指定 SM2 密文的长度，便于正确分割数据
- **格式**：大端序 32 位整数
- **示例**：128 字节的 SM2 密文编码为 `00 00 00 80`

#### 2. SM2加密的密钥

- **内容**：使用 SM2 公钥加密的 SM4 对称密钥
- **长度**：由第一部分指定
- **作用**：保护对称密钥的安全传输

#### 3. SM4加密的敏感数据

- **内容**：使用 SM4 对称密钥加密的原始敏感数据
- **长度**：剩余的所有字节
- **作用**：保护实际业务数据

### 加密流程

```java
// 1. 获取或生成密钥
KeyInfo keyInfo = keyManager.getOrCreateSessionKeyInfo(traceId);
SecretKey sm4Key = keyInfo.getSm4Key();
byte[] sm2EncryptedKey = keyInfo.getSm2EncryptedKey();

// 2. 使用SM4加密敏感数据
// 生成随机IV/nonce（GCM建议12字节），并使用SM4-GCM加密
byte[] iv = new byte[12];
random.nextBytes(iv);
byte[] encryptedData = encryptWithSm4Gcm(sensitiveData.getBytes("UTF-8"), sm4Key, iv);

// 3. 构建SECURE_DATA结构
// [version(1)][sm2KeyLen(4)][ivLen(1)][sm2Key][iv][sm4Ciphertext]
byte[] combined = new byte[1 + 4 + 1 + sm2EncryptedKey.length + iv.length + encryptedData.length];

// 4. Base64编码
return EccCore.base64Encode(combined);
```

### 解密流程

```java
// 1. Base64解码
byte[] combined = EccCore.base64Decode(secureData);

// 2. 读取头部信息
int version = combined[0] & 0xFF;
int keyLength = ((combined[1] & 0xFF) << 24) | ((combined[2] & 0xFF) << 16) |
                ((combined[3] & 0xFF) << 8) | (combined[4] & 0xFF);
int ivLen = combined[5] & 0xFF;

// 3. 分割数据
int offset = 6;
byte[] encryptedKey = Arrays.copyOfRange(combined, offset, offset + keyLength);
offset += keyLength;
byte[] iv = Arrays.copyOfRange(combined, offset, offset + ivLen);
offset += ivLen;
byte[] encryptedData = Arrays.copyOfRange(combined, offset, combined.length);

// 4. 使用SM2私钥解密得到SM4密钥
byte[] sm4KeyBytes = EccCore.decrypt(encryptedKey, privateKey);
SecretKey sm4Key = new SecretKeySpec(sm4KeyBytes, "SM4");

// 5. 使用SM4解密敏感数据
byte[] decryptedData = decryptWithSm4Gcm(encryptedData, sm4Key, iv);
String sensitiveData = new String(decryptedData, "UTF-8");
```

### 设计优势

#### 安全性

- **双重加密**：SM2（非对称）+ SM4（对称）混合加密
- **密钥保护**：对称密钥使用非对称加密保护
- **国密标准**：符合国家密码管理局标准

#### 性能优化

- **对称加密**：SM4 性能优秀，适合大数据量
- **非对称加密**：SM2 仅用于加密密钥，性能影响小
- **密钥复用**：同一 trace_id 或时间间隔内密钥复用

#### 可扩展性

- **长度信息**：支持变长的 SM2 密文
- **结构清晰**：便于解析和处理
- **标准格式**：易于与其他系统集成

## 业务操作指南

### 1. 初始化组件

```java
// 使用默认配置
SecureDataBuilder builder = new SecureDataBuilder();

// 使用自定义KeyManager
KeyManager keyManager = new KeyManager(50000, 2000); // 会话缓存大小=50000，系统缓存大小=2000
SecureDataBuilder builder = new SecureDataBuilder(keyManager);
```

### 2. 加密业务日志（有trace_id）

```java
// 业务日志：包含trace_id
String traceId = "1234567890";
String sensitiveData = "password=123456&token=abc123";

String secureData = builder.buildSecureDataForBusinessLog(sensitiveData, traceId);
// 输出：Base64编码的SECURE_DATA，结构为：
// [4字节长度] + [SM2加密的SM4密钥] + [SM4加密的敏感数据]
```

### 3. 加密系统日志（无trace_id）

```java
// 系统日志：无trace_id
String sensitiveData = "database connection failed with password=123456";

String secureData = builder.buildSecureDataForSystemLog(sensitiveData);
// 输出：Base64编码的SECURE_DATA
```

### 4. 日志框架集成

#### 执行顺序与MDC规则（重要）

- **执行顺序固定**：先按日志框架 pattern/ConversionPattern 生成“最终文本”，再对该文本做敏感识别、脱敏，并生成 SECURE_DATA。
- **SECURE_DATA 的写入位置**：SECURE_DATA 写入 MDC 是为了“同线程上下文的附加信息传递”，不是为了保证能在同一条日志 pattern 中输出。
- **避免串值**：组件会在下一次日志处理开始前清空 `SECURE_DATA`，避免 `%X{SECURE_DATA}` 或事件上下文误读上一条日志的残留值。
- **输出建议**：默认不建议在日志正文输出 `SECURE_DATA`；如果确需输出，应通过单独字段/单独通道输出，并明确它不保证与当前行一一对应。

#### Logback（logback.xml）

Logback 使用 `SecureMaskingAppender` 包装目标 Appender，在转发前对消息做脱敏，并把 `SECURE_DATA` 写入事件 MDC（配合 GELF encoder 的 `includeMdcData=true`
一起发送）。

```xml

<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <appender name="SECURE_CONSOLE" class="team.frog.securelogecc.logback.SecureMaskingAppender">
        <appender-ref ref="CONSOLE"/>
    </appender>

    <root level="info">
        <appender-ref ref="SECURE_CONSOLE"/>
    </root>
</configuration>
```

#### Log4j2（log4j2.xml）

Log4j2 使用内置的 `Rewrite` 包装目标 Appender，并使用组件提供的 `SecureMaskingPolicy` 在转发前脱敏。需要在 `<Configuration>`
上配置 `packages="team.frog.securelogecc.log4j2"` 让 Log4j2 扫描到插件。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="INFO" packages="team.frog.securelogecc.log4j2">
    <Appenders>
        <Console name="CONSOLE" target="SYSTEM_OUT">
            <PatternLayout pattern="Log4j2 %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>

        <Rewrite name="SECURE_CONSOLE">
            <SecureMaskingPolicy/>
            <AppenderRef ref="CONSOLE"/>
        </Rewrite>
    </Appenders>
    <Loggers>
        <Root level="info">
            <AppenderRef ref="SECURE_CONSOLE"/>
        </Root>
    </Loggers>
</Configuration>
```

## 性能优化特性

### 1. 极致性能设计

- **时间复杂度**：密钥获取O(1)，缓存清理O(k)（k=需要清理的数量）
- **空间复杂度**：固定大小的缓存，避免内存泄漏
- **并发性能**：99%情况下无锁读取，极致性能

### 2. 简化高效算法

- **SM4加密**：对称加密，性能优秀
- **SM2加密**：仅用于加密对称密钥，性能影响小
- **密钥复用**：同一trace_id或时间间隔内密钥复用
- **无锁设计**：消除双重检查锁定，代码更简洁

### 3. 智能内存管理

- **缓存限制**：会话密钥30,000条，系统密钥1,000条
- **自动清理**：缓存占满后按创建时间清理
- **缓冲机制**：清理时保留缓冲空间，避免频繁清理
- **时间一致性**：统一时间戳，确保清理顺序正确

## 安全特性

### 1. 密钥安全

- **密钥分离**：会话密钥和系统密钥完全隔离
- **密钥加密**：SM4密钥使用SM2加密存储
- **密钥轮换**：系统密钥按时间间隔自动轮换

### 2. 数据安全

- **敏感数据检测**：按强敏感key命中 + SQL结构解析 + 值形态命中综合识别
- **完整加密**：敏感数据和密钥都进行加密
- **加密模式**：当前实现使用 `SM4/GCM/NoPadding`（随机IV/nonce + 认证标签，支持防篡改）

### 3. 配置安全

- **配置加密**：ECC公钥Base64编码存储
- **默认安全**：提供安全的默认配置值
- **配置验证**：配置值范围检查和验证

## 部署和运维

### 1. 依赖管理

```xml
<dependencies>
    <!-- Bouncy Castle密码学提供者 -->
    <dependency>
        <groupId>org.bouncycastle</groupId>
        <artifactId>bcprov-jdk15on</artifactId>
        <version>1.70</version>
    </dependency>
  
    <!-- 日志框架集成 -->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.2.11</version>
    </dependency>
</dependencies>
```

### 2. 监控指标

建议监控以下指标：

- 缓存命中率
- 密钥创建频率
- 缓存清理次数
- 加密操作耗时

### 3. 故障排除

常见问题及解决方案：

- **内存溢出**：检查缓存配置大小是否合理
- **性能下降**：监控缓存命中率和清理频率
- **加密失败**：检查ECC公钥配置是否正确

## 版本历史

### v1.0.0（当前版本）

- 初始版本发布
- 支持双轨密钥管理
- 基于ConcurrentHashMap + ConcurrentLinkedQueue的缓存优化
- 完整的配置管理系统

### 最新优化（v1.0.1）

- ✅ **简化密钥获取逻辑**：消除双重检查锁定，采用"能取到就返回，没有取到就生成"策略
- ✅ **时间一致性优化**：使用统一时间戳，避免时间不一致问题
- ✅ **极致性能设计**：99%情况下无锁读取，极致性能
- ✅ **代码简洁性**：逻辑清晰，易于维护

### 技术债务清理

- ✅ 删除未使用的setter/getter方法
- ✅ 统一配置读取模板方法
- ✅ 消除魔法数字，使用时间单位常量
- ✅ 重命名"时间窗口"为"系统标识符变化间隔"
- ✅ 优化缓存清理算法，消除排序操作开销

## 总结

SecureLog ECC 是一个成熟、高性能的日志加密组件，通过双轨密钥管理系统和优化的缓存策略，为业务系统提供了可靠的敏感数据保护。组件设计考虑了性能、安全和可维护性，适合在生产环境中部署使用。
